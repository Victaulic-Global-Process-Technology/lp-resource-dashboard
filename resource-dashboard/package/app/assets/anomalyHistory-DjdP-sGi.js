import{d as y,t as z,g as x,a as q,e as D}from"./index-CmBIJSzo.js";import{isRuleEnabled as j,getThreshold as $,isCustomValue as b,getRuleSeverity as P}from"./anomalyRules-sVyOhB1E.js";function B(l){const g=l.person||l.projectId||"global";return`${l.ruleId}::${g}`}async function L(l,g){const I=await y.anomalyThresholds.toArray(),o=new Map(I.map(e=>[e.ruleId,e])),M=l?z(D(l)):null;let w=M?await y.timesheets.where("month").anyOf(M).toArray():await y.timesheets.toArray();if(g&&(w=w.filter(e=>x(e.r_number)===g||e.r_number===g)),w.length===0)return[];const _=await y.teamMembers.toArray(),d=new Set(_.map(e=>e.full_name)),A=await y.projects.toArray(),C=new Map(A.map(e=>[e.project_id,e])),m=[],S=new Map;for(const e of w){const n=S.get(e.full_name)??[];n.push(e),S.set(e.full_name,n)}for(const[e,n]of S){if(!d.has(e))continue;const r=new Map,a=new Map;let v=0,f=0,u=0;for(const t of n){u+=t.hours,r.set(t.date,(r.get(t.date)??0)+t.hours);const s=a.get(t.date)??new Set;t.r_number&&s.add(t.r_number),a.set(t.date,s),t.task?.toLowerCase().includes("meeting")&&(v+=t.hours),C.get(t.r_number)?.work_class==="Unplanned/Firefighting"&&(f+=t.hours)}if(j(o,"overtime")){const t=$(o,"overtime","minDaysOver8"),s=$(o,"overtime","dailyHoursThreshold"),h=[...r.values()].filter(c=>c>s).length;if(h>=t){const c=r.size>0?u/r.size:0,p=b(o,"overtime","minDaysOver8")||b(o,"overtime","dailyHoursThreshold");m.push({type:"overtime",severity:P(o,"overtime"),title:`${e} logged overtime on ${h} days`,detail:`Averaged ${c.toFixed(1)} hrs/day across ${r.size} work days.`,person:e,ruleId:"overtime",thresholdComparison:`overtime days (${h}) >= threshold (${t}) with >${s}h/day`,isCustomThreshold:p,customThresholdLabel:p?`>${t} days over ${s}h`:void 0})}}if(j(o,"context-switching")){const t=$(o,"context-switching","focusScoreThreshold"),s=a.size;if(s>0){const h=[...a.values()].map(T=>T.size),c=h.reduce((T,k)=>T+k,0)/s,p=Math.min(100,Math.round(100/c)),F=h.filter(T=>T>3).length;if(p<t){const T=b(o,"context-switching","focusScoreThreshold"),k=new Set(n.map(O=>O.r_number).filter(Boolean)).size;m.push({type:"context-switching",severity:P(o,"context-switching"),title:`${e} is highly fragmented across ${k} projects`,detail:`Averaged ${c.toFixed(1)} projects/day with ${F} high-fragmentation days.`,person:e,ruleId:"context-switching",thresholdComparison:`focus score (${p}) < threshold (${t})`,isCustomThreshold:T,customThresholdLabel:T?`score < ${t}`:void 0})}}}if(j(o,"meeting-heavy")&&u>0){const t=$(o,"meeting-heavy","meetingPctThreshold")/100,s=v/u;if(s>t){const h=b(o,"meeting-heavy","meetingPctThreshold");m.push({type:"meeting-heavy",severity:P(o,"meeting-heavy"),title:`${e} spent ${Math.round(s*100)}% in meetings`,detail:`${Math.round(v)}h of ${Math.round(u)}h total.`,person:e,ruleId:"meeting-heavy",thresholdComparison:`meeting time (${Math.round(s*100)}%) > threshold (${Math.round(t*100)}%)`,isCustomThreshold:h,customThresholdLabel:h?`>${Math.round(t*100)}%`:void 0})}}if(j(o,"firefighting-spike")&&u>0){const t=$(o,"firefighting-spike","firefightingPctThreshold")/100,s=f/u;if(s>t){const h=b(o,"firefighting-spike","firefightingPctThreshold");m.push({type:"firefighting-spike",severity:P(o,"firefighting-spike"),title:`${e} has ${Math.round(s*100)}% firefighting`,detail:`${Math.round(f)}h unplanned/firefighting out of ${Math.round(u)}h.`,person:e,ruleId:"firefighting-spike",thresholdComparison:`firefighting (${Math.round(s*100)}%) > threshold (${Math.round(t*100)}%)`,isCustomThreshold:h,customThresholdLabel:h?`>${Math.round(t*100)}%`:void 0})}}}const H=new Map;for(const e of w){if(!e.r_number)continue;const n=H.get(e.r_number)??new Map;n.set(e.full_name,(n.get(e.full_name)??0)+e.hours),H.set(e.r_number,n)}if(j(o,"bus-factor")){const e=$(o,"bus-factor","maxBusFactor"),n=$(o,"bus-factor","minProjectHours"),r=$(o,"bus-factor","projectTypesFilter")===1;for(const[a,v]of H){const f=C.get(a);if(!f||r&&f.type!==q.NPD)continue;const u=[...v.values()].reduce((c,p)=>c+p,0);if(u<n)continue;const t=[...v.entries()].map(([c,p])=>({person:c,hours:p,pct:p/u})).sort((c,p)=>p.hours-c.hours);let s=0,h=0;for(const c of t)if(s+=c.pct,h++,s>.5)break;if(h<=e){const c=t[0],p=b(o,"bus-factor","maxBusFactor")||b(o,"bus-factor","minProjectHours");m.push({type:"single-point-of-failure",severity:P(o,"bus-factor"),title:`${f.project_name||a} depends solely on ${c.person}`,detail:`${Math.round(u)}h logged by ${t.length} contributor${t.length>1?"s":""} (top: ${Math.round(c.pct*100)}%).`,person:c.person,projectId:a,ruleId:"bus-factor",thresholdComparison:`bus factor (${h}) <= threshold (${e}) with ${Math.round(u)}h > ${n}h min`,isCustomThreshold:p,customThresholdLabel:p?`bus factor <= ${e}, min ${n}h`:void 0})}}}if(l){const e=D(l);let n=await y.plannedProjectMonths.where("month").anyOf(e).toArray();g&&(n=n.filter(r=>r.project_id===g||x(r.project_id)===g));for(const r of n){if(r.total_planned_hours<=0)continue;const a=H.get(r.project_id),v=a?[...a.values()].reduce((t,s)=>t+s,0):0,f=v/r.total_planned_hours,u=C.get(r.project_id);if(j(o,"project-over-burn")){const t=$(o,"project-over-burn","overBurnPct")/100;if(f>1+t){const s=b(o,"project-over-burn","overBurnPct");m.push({type:"project-over-burn",severity:P(o,"project-over-burn"),title:`${u?.project_name||r.project_id} over-burning at ${Math.round(f*100)}%`,detail:`${Math.round(v)}h actual vs ${Math.round(r.total_planned_hours)}h planned.`,projectId:r.project_id,ruleId:"project-over-burn",thresholdComparison:`actual/planned ratio (${Math.round(f*100)}%) > threshold (${Math.round((1+t)*100)}%)`,isCustomThreshold:s,customThresholdLabel:s?`>${Math.round(t*100)}% over plan`:void 0})}}if(j(o,"project-under-burn")&&v>0){const t=$(o,"project-under-burn","underBurnPct")/100;if(f<t){const s=b(o,"project-under-burn","underBurnPct");m.push({type:"project-under-burn",severity:P(o,"project-under-burn"),title:`${u?.project_name||r.project_id} under-burning at ${Math.round(f*100)}%`,detail:`${Math.round(v)}h actual vs ${Math.round(r.total_planned_hours)}h planned.`,projectId:r.project_id,ruleId:"project-under-burn",thresholdComparison:`actual/planned ratio (${Math.round(f*100)}%) < threshold (${Math.round(t*100)}%)`,isCustomThreshold:s,customThresholdLabel:s?`<${Math.round(t*100)}% of plan`:void 0})}}}}if(j(o,"new-person")&&M){const e=new Set(M),n=await y.timesheets.toArray(),r=new Set;for(const a of n)e.has(a.month)||r.add(a.full_name);for(const a of S.keys())!r.has(a)&&d.has(a)&&m.push({type:"new-person",severity:P(o,"new-person"),title:`${a} is new this month`,detail:"First time appearing in timesheet data.",person:a,ruleId:"new-person"})}const i={alert:0,warning:1,info:2};return m.sort((e,n)=>(i[e.severity]??2)-(i[n.severity]??2)),m}async function N(l,g){const M=(await L(l,void 0)).map(d=>({anomaly_id:B(d),type:d.type,severity:d.severity,title:d.title,detail:d.detail,person:d.person,projectId:d.projectId,ruleId:d.ruleId})),w=new Date().toISOString(),_=await y.anomalyHistory.where("[month+project_filter]").equals([l,""]).first();_&&_.id!=null?await y.anomalyHistory.update(_.id,{computed_at:w,anomalies:M}):await y.anomalyHistory.add({month:l,project_filter:"",computed_at:w,anomalies:M})}async function U(l,g){const I=g??"",o=await y.anomalyHistory.where("[month+project_filter]").equals([l,I]).first();if(!o)return(await L(l,I||void 0)).map(e=>({anomaly_id:B(e),type:e.type,severity:e.severity,title:e.title,detail:e.detail,person:e.person,projectId:e.projectId,ruleId:e.ruleId,status:"new"}));const w=(await y.anomalyHistory.where("project_filter").equals(I).sortBy("month")).filter(i=>i.month<l),_=new Set(o.anomalies.map(i=>i.anomaly_id)),d=new Map,A=[...w].reverse();for(const i of A){const e=new Set(i.anomalies.map(r=>r.anomaly_id));let n=!1;for(const r of _)e.has(r)&&(d.set(r,(d.get(r)??0)+1),n=!0);if(!n)break}const C=A[0],m=o.anomalies.map(i=>{const e=d.get(i.anomaly_id)??0;return{...i,status:e>0?"recurring":"new",recurring_months:e>0?e:void 0}});if(C)for(const i of C.anomalies)_.has(i.anomaly_id)||m.push({...i,status:"resolved"});const S=await y.anomalyThresholds.toArray(),H=new Map(S.map(i=>[i.ruleId,i]));return m.filter(i=>j(H,i.ruleId))}export{L as c,U as g,N as r};
